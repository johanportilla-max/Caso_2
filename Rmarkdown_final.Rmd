---
title: "Modelos de Clasificación para Riesgo Crediticio"
author: "Barros Rayo Alejandro (2415837), Muñoz Portela Diego Fernando (2415620), Portilla Aguirre Johan Camilo (2422468), Aguirre Aldana Joan Sebastian (2419550)"
output: 
  html_document:
    theme: lumen
    highlight: textmate
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    toc_depth: 3
    number_sections: true
    code_folding: show
---
# Introducción


# Metodología

## Fuente de datos 
## Definición de variables


## Preparación y limpieza de datos 
# Análisis descriptivo
```{r sep, include=FALSE}

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(dplyr)
library(tidyr)
library(readr)
library(tidyverse)
library(class)
library(caret)
library(pROC)
library(ggthemes)
library(lubridate)
library(kableExtra)
library(knitr)
library(ggcorrplot)
library(scales)
```


```{r tema2, include=FALSE}
tema <- theme_minimal() +
  theme(
    text = element_text(family = "Segoe UI", color = "#2d3748"),
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5, color = "#323130"),
    plot.subtitle = element_text(size = 12, hjust = 0.5, color = "#605e5c", margin = margin(b = 15)),
    plot.caption = element_text(size = 10, color = "#605e5c", hjust = 0),
    panel.grid.major = element_line(color = "#f3f2f1"),
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    axis.title = element_text(face = "bold", color = "#323130"),
    axis.text = element_text(color = "#605e5c"),
    legend.position = "none"
  )
```
```{r carga_datos, include=FALSE}
# Chunk 3: Carga y preprocesamiento de datos
lending_raw <- read_csv("LC_loans_granting_model_dataset.csv", guess_max = 20000)

lending_base <- lending_raw %>%
  select(revenue, dti_n, loan_amnt, fico_n, Default, purpose, issue_d) %>%
  rename(
    ingreso = revenue,
    relacion_deuda_ingreso = dti_n,
    monto_prestamo = loan_amnt,
    puntaje_fico = fico_n,
    estado_pago = Default,
    proposito = purpose
  ) %>%
  mutate(
    fecha_emision = parse_date_time(issue_d, orders = "b-Y", locale = "en_US"),
    Año = year(fecha_emision),
    proposito = as.factor(proposito),
    proposito_agrupado = fct_collapse(
      proposito,
      Consolidacion = c("debt_consolidation", "credit_card"),
      Casa_Vehiculo = c("home_improvement", "major_purchase", "car", "house"),
      Negocio_Estudio = c("small_business", "educational")
    ),
    proposito_agrupado = fct_other(
      proposito_agrupado,
      keep = c("Consolidacion", "Casa_Vehiculo", "Negocio_Estudio"),
      other_level = "Otros"
    ),
    estado_pago = fct_recode(as.factor(estado_pago), "Paga" = "0", "No_paga" = "1")
  ) %>%
  select(-proposito)

# Filtro de outliers y eliminación de NAs
lending_base <- lending_base %>%
  filter(ingreso <= 250000, relacion_deuda_ingreso <= 50) %>%
  drop_na()
```

```{r resumen_general, include=FALSE}
# Chunk 4: Resumen general de variables
resumen_general <- lending_base %>%
  select(ingreso, relacion_deuda_ingreso, monto_prestamo, puntaje_fico) %>%
  summarise_all(list(
    n = ~sum(!is.na(.)),
    media = ~mean(., na.rm = TRUE),
    mediana = ~median(., na.rm = TRUE),
    sd = ~sd(., na.rm = TRUE),
    minimo = ~min(., na.rm = TRUE),
    maximo = ~max(., na.rm = TRUE)
  )) %>%
  pivot_longer(
    cols = everything(),
    names_to = c("variable", ".value"),
    names_pattern = "^(.*)_(n|media|mediana|sd|minimo|maximo)$"
  )
```

```{r tabla_resumen, include=FALSE}
# Chunk 5: Tabla resumen con estilo
tabla_resumen = resumen_general %>%
  kable("html", caption = "Resumen de variables principales",
        col.names = c("Variable", "N", "Media", "Mediana", "Desviación estándar", "Mínimo", "Máximo"),
        align = "c") %>%
  kable_styling(bootstrap_options = c("striped","hover","condensed","responsive"),
                full_width = FALSE, position = "center") %>%
  column_spec(1, bold = TRUE, background = "skyblue", color = "black") %>%
  row_spec(0, background = "skyblue", color = "black") %>%
  footnote(general = "Datos de préstamos Lending Club",
           number = c("Montos en dólares", "Variables numéricas seleccionadas"),
           alphabet = c("Valores procesados y filtrados."),
           symbol = c("Tabla resumen de variables."))

tabla_resumen
```



## Distribución de las variables principales
## Caracterización de las clases
## Comportamiento según propósito del préstamo
# Modelos de clasificación
## División de los datos

Para el desarrollo de los modelos de clasificación, se realizó un muestreo estratificado balanceado seguido de una partición aleatoria, con el objetivo de mitigar el desbalance inherente en el dataset original de Lending Club, donde aproximadamente el 82% de las observaciones corresponden a préstamos pagados y solo el 18% a incumplimientos, lo que podría sesgar los algoritmos hacia la clase mayoritaria. Inicialmente, de la base filtrada y limpia ("lending_base"), se extrajo una muestra aleatoria de 10,000 observaciones utilizando sample_n() en R con semilla fija (set.seed(28)) para reproducibilidad: 5,000 de la clase "Paga" y 5,000 de "No_paga", aplicando undersampling a la clase dominante para igualar las proporciones y mejorar la sensibilidad de los modelos en la detección de riesgos crediticios. Esta técnica de balanceo es estándar en problemas de clasificación binaria desbalanceada, como los de préstamos P2P, ya que permite evaluaciones más robustas de métricas como precisión, recall y AUC sin requerir oversampling sintético.

Posteriormente, la muestra balanceada ("lending_muestra") se dividió en subconjuntos de entrenamiento (75% de las observaciones, equivalente a 7,500 registros) y prueba (25%, o 2,500 registros), utilizando sample() con la misma semilla para mantener la aleatoriedad controlada y preservar el equilibrio equitativo entre clases en ambos conjuntos (aproximadamente 50% "Paga" y 50% "No_paga"). La proporción 75/25 es una convención común en machine learning para clasificación, ya que proporciona suficientes datos para el entrenamiento mientras reserva un conjunto de prueba independiente para validar el rendimiento generalizado, evitando sobreajuste en datasets de riesgo crediticio como el de Lending Club. Esta división se implementó mediante índices aleatorios (index_entrena e index_test), asegurando que las variables predictoras (numéricas y categóricas) se mantuvieran representativas en ambos subconjuntos para una evaluación imparcial de los modelos KNN y logit.

## Modelo KNN

El modelo K-Nearest Neighbors (KNN) es un algoritmo de aprendizaje supervisado no paramétrico, ampliamente utilizado para problemas de clasificación, donde predice la clase de un nuevo punto de datos basándose en la mayoría de clases de sus k vecinos más cercanos en el espacio de características. Este método opera de manera "perezosa", ya que no construye un modelo explícito durante el entrenamiento, sino que almacena el conjunto de datos y realiza cálculos de distancia (como la euclidiana) solo en el momento de la predicción, lo que lo hace simple e intuitivo para capturar patrones locales en los datos.

### Modelo KNN (class)

El modelo KNN fue entrenado utilizando únicamente variables numéricas estandarizadas 
(`ingreso`, `relación deuda/ingreso`, `monto del préstamo`, y `puntaje FICO`).  
Se evaluaron diferentes valores de *k* (número de vecinos)

### Modelo KNN (caret)
## Modelo Logit

El modelo de regresión logística (logit) es un algoritmo de aprendizaje supervisado paramétrico diseñado principalmente para clasificación binaria, que estima la probabilidad de que una observación pertenezca a una clase específica (por ejemplo, pago o no pago) mediante la aplicación de la función sigmoide a una combinación lineal de las variables predictoras. A diferencia de la regresión lineal, transforma las salidas en valores entre 0 y 1, permitiendo interpretaciones probabilísticas y umbrales para decisiones de clasificación, lo que lo hace ideal para modelar relaciones no lineales en datos categóricos.


# Comparación de modelos
# Conclusiones 
# Bibliografia 
rfirawvjbkwbj
```{r setup, include=FALSE}



knitr::opts_chunk$set(echo = TRUE)
```

```{r cars}
```



```{r pressure, echo=FALSE}
```


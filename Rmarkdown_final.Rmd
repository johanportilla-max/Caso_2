---
title: "Modelos de Clasificación para Riesgo Crediticio"
author: "Barros Rayo Alejandro (2415837), Muñoz Portela Diego Fernando (2415620), Portilla Aguirre Johan Camilo (2422468), Aguirre Aldana Joan Sebastian (2419550)"
output: 
  html_document:
    theme: lumen
    highlight: textmate
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    toc_depth: 3
    number_sections: true
    code_folding: show
---

# Introducción

# Metodología

## Fuente de datos

## Definición de variables

## Preparación y limpieza de datos

# Análisis descriptivo

```{r sep, echo = FALSE, warning = FALSE, message = FALSE}

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(dplyr)
library(tidyr)
library(readr)
library(tidyverse)
library(class)
library(caret)
library(pROC)
library(ggthemes)
library(lubridate)
library(kableExtra)
library(knitr)
library(ggcorrplot)
library(scales)
library(gridExtra)
library(grid)
library(ggplotify)

```

```{r tema2, echo = FALSE, warning = FALSE, message = FALSE}
tema <- theme_minimal() +
  theme(
    text = element_text(family = "Segoe UI", color = "#2d3748"),
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5, color = "#323130"),
    plot.subtitle = element_text(size = 12, hjust = 0.5, color = "#605e5c", margin = margin(b = 15)),
    plot.caption = element_text(size = 10, color = "#605e5c", hjust = 0),
    panel.grid.major = element_line(color = "#f3f2f1"),
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    axis.title = element_text(face = "bold", color = "#323130"),
    axis.text = element_text(color = "#605e5c"),
    legend.position = "none"
  )
```

```{r carga_datos, echo = FALSE, warning = FALSE, message = FALSE}
lending_raw <- read_csv("LC_loans_granting_model_dataset.csv", guess_max = 20000)

lending_base <- lending_raw %>%
  select(revenue, dti_n, loan_amnt, fico_n, Default, purpose, issue_d) %>%
  rename(
    ingreso = revenue,
    relacion_deuda_ingreso = dti_n,
    monto_prestamo = loan_amnt,
    puntaje_fico = fico_n,
    estado_pago = Default,
    proposito = purpose
  ) %>%
  mutate(
    fecha_emision = parse_date_time(issue_d, orders = "b-Y", locale = "en_US"),
    Año = year(fecha_emision),
    proposito = as.factor(proposito),
    proposito_agrupado = fct_collapse(
      proposito,
      Consolidacion = c("debt_consolidation", "credit_card"),
      Casa_Vehiculo = c("home_improvement", "major_purchase", "car", "house"),
      Negocio_Estudio = c("small_business", "educational")
    ),
    proposito_agrupado = fct_other(
      proposito_agrupado,
      keep = c("Consolidacion", "Casa_Vehiculo", "Negocio_Estudio"),
      other_level = "Otros"
    ),
    estado_pago = fct_recode(as.factor(estado_pago), "Paga" = "0", "No_paga" = "1")
  ) %>%
  select(-proposito)

lending_base <- lending_base %>%
  filter(ingreso <= 250000, relacion_deuda_ingreso <= 50) %>%
  drop_na()
```

```{r resumen_general, echo = FALSE, warning = FALSE, message = FALSE}

resumen_general <- lending_base %>%
  select(ingreso, relacion_deuda_ingreso, monto_prestamo, puntaje_fico) %>%
  summarise_all(list(
    n = ~sum(!is.na(.)),
    media = ~mean(., na.rm = TRUE),
    mediana = ~median(., na.rm = TRUE),
    sd = ~sd(., na.rm = TRUE),
    minimo = ~min(., na.rm = TRUE),
    maximo = ~max(., na.rm = TRUE)
  )) %>%
  pivot_longer(
    cols = everything(),
    names_to = c("variable", ".value"),
    names_pattern = "^(.*)_(n|media|mediana|sd|minimo|maximo)$"
  )
```

titulo1 Introducción general del dataset

```{r tabla_resumen }

tabla_resumen = resumen_general %>%
  select(-n) %>%  
  kable(
    format = "html",
    col.names = c("Variable", "Media", "Mediana", "Desv. Estándar", "Mínimo", "Máximo"),
    align = c('l', 'r', 'r', 'r', 'r', 'r'),
    caption = "Tabla 1: Estadísticas Descriptivas de las Variables Principales del Dataset de Préstamos"
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    font_size = 14,
    position = "center"
  ) %>%
  row_spec(0, background = "#2b6cb0", color = "white", bold = TRUE) %>%
  column_spec(1, bold = TRUE, width = "3cm") %>%
  column_spec(2, width = "2cm") %>%
  column_spec(3, width = "2cm") %>%
  column_spec(4, width = "2.5cm") %>%
  column_spec(5, width = "2cm") %>%
  column_spec(6, width = "2cm") %>%
  footnote(
    general = "Fuente: Elaboración propia con base en datos de Lending Club",
    general_title = "Nota:",
    footnote_as_chunk = TRUE
  )

tabla_resumen
```

palabras sobre la tabla

```{r tabla_frecuencias}

tabla_estado <- as.data.frame(table(lending_base$estado_pago))
colnames(tabla_estado) <- c("estado_pago", "n")
tabla_estado$porcentaje <- round(prop.table(tabla_estado$n) * 100, 2)

tabla_estado %>%
  kbl(
    caption = "Tabla 2: Distribución de Frecuencias por Estado de Pago",
    align = c("l", "r", "r"),
    col.names = c("Estado Pago", "Frecuencia", "Porcentaje (%)")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    font_size = 14,
    position = "center"
  ) %>%
  row_spec(0, background = "#2b6cb0", color = "white", bold = TRUE) %>%
  column_spec(1, bold = TRUE, width = "3cm") %>%
  column_spec(2:3, width = "2.5cm") %>%
  footnote(
    general = "Fuente: Elaboración propia con base en datos de Lending Club",
    general_title = "Nota:",
    footnote_as_chunk = TRUE
  )
```

hablar sobre tabla 2

titulo2 Distribución individual de variables numéricas

```{r p1}
library(plotly)

p1 <- ggplot(lending_base, aes(x = ingreso)) +
  geom_histogram(binwidth = 5000,
                 fill = "#2b6cb0",
                 color = "white",
                 alpha = 0.8) +
  geom_vline(xintercept = median(lending_base$ingreso, na.rm = TRUE),
             color = "red", linetype = "dashed", size = 0.9) +
  scale_x_continuous(labels = scales::dollar_format(prefix = "$", big.mark = ",")) +
  scale_y_continuous(labels = scales::comma_format()) +
  labs(
    title = "Histograma de ingreso (mediana en rojo)",
    x = "Ingreso",
    y = "Frecuencia"
  ) +
  tema
p1

```

comentario histograma

```{r pdti}
p_dti <- ggplot(lending_base, aes(x = relacion_deuda_ingreso)) +
  geom_density(fill = "#2a9d8f",       
               color = "#1b4d47",      
               alpha = 0.4,
               size = 1.1) +
  geom_vline(aes(xintercept = median(relacion_deuda_ingreso, na.rm = TRUE)),
             color = "red", linetype = "dashed", size = 0.9) +
  scale_x_continuous(labels = scales::percent_format(scale = 1)) +
  scale_y_continuous(labels = scales::comma_format()) +
  labs(
    title = "Distribución de la relación deuda/ingreso",
    x = "Relación deuda/ingreso (%)",
    y = "Densidad"
  ) +
  tema

p_dti


```

comentario distribucion

```{r fico}
p_fico <- ggplot(lending_base, aes(x = puntaje_fico)) +
  geom_density(
    bw = 15,                # suaviza la curva (ajusta entre 10–25 según tus datos)
    fill = "#52b788",       # verde más elegante
    color = "#1b4332",      # borde oscuro
    alpha = 0.8,
    size = 1.1
  ) +
  geom_vline(
    xintercept = median(lending_base$puntaje_fico, na.rm = TRUE),
    color = "#e63946", linetype = "dashed", size = 1
  ) +
  scale_x_continuous(
    breaks = seq(600, 850, 25),
    limits = c(600, 850)
  ) +
  scale_y_continuous(
    expand = expansion(mult = c(0, 0.05)),
    labels = scales::comma_format()
  ) +
  labs(
    title = "Distribución del puntaje FICO",
    x = "Puntaje FICO",
    y = "Densidad"
  ) +
  tema +
  theme(
    plot.title = element_text(face = "bold", size = 14, color = "#1b4332"),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    panel.grid.minor = element_blank()
  )

p_fico


```

comentario fico

```{r p_monto}
p_monto_hist <- ggplot(lending_base, aes(x = monto_prestamo)) +
  geom_histogram(binwidth = 1000,
                 fill = "#2a9d8f",  
                 color = "white",
                 alpha = 0.9) +
  geom_vline(aes(xintercept = median(monto_prestamo, na.rm = TRUE)),
             color = "red", linetype = "dashed", size = 0.9) +
  scale_x_continuous(labels = dollar_format(prefix = "$", big.mark = ",")) +
  scale_y_continuous(labels = comma_format()) +
  labs(
    title = "Distribución del monto del préstamo (mediana en rojo)",
    x = "Monto del préstamo (USD)",
    y = "Frecuencia"
  ) +
  tema
p_monto_hist

```

comentario monto

titulo3 Comparación entre clases (Paga vs No_paga)

```{r fico_dti_simplificado}

set.seed(123)

sample_plot <- lending_base %>% sample_n(min(8000, nrow(.)))

p_fico_dti <- ggplot(sample_plot, aes(x = puntaje_fico, y = relacion_deuda_ingreso)) +
  geom_smooth(
    method = "loess",
    se = TRUE,
    color = "#1b4332",
    fill = "#95d5b2",
    linewidth = 1.2,
    alpha = 0.3
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1)) +
  scale_x_continuous(breaks = seq(600, 850, 25)) +
  labs(
    title = "Relación entre puntaje FICO y relación deuda/ingreso",
    
    x = "Puntaje FICO",
    y = "Relación deuda/ingreso (%)"
  ) +
  tema +
  theme(
    legend.position = "none",
    plot.subtitle = element_text(size = 11, color = "#555"),
    panel.grid.minor = element_blank()
  )

p_fico_dti

```

```{r montovsingresos}
p_monto <- ggplot(lending_base, aes(x = ingreso, y = monto_prestamo)) +
geom_point(aes(color = estado_pago),
alpha = 0.5, size = 1.8) +
geom_smooth(method = "loess", se = TRUE,
color = "#1b4332", fill = "#95d5b2", size = 1) +
scale_x_continuous(labels = dollar_format(prefix = "$", big.mark = ",")) +
scale_y_continuous(labels = dollar_format(prefix = "$", big.mark = ",")) +
scale_color_manual(values = c("Paga" = "#74c69d", "No_paga" = "#e63946")) +
labs(
title = "Relación entre ingreso y monto del préstamo",
x = "Ingreso del solicitante (USD)",
y = "Monto del préstamo (USD)",
color = "Estado de pago"
) +
tema +
theme(legend.position = "bottom")
p_monto
```

## Distribución de las variables principales

## Caracterización de las clases

## Comportamiento según propósito del préstamo

# Modelos de clasificación

La clasificación es un enfoque fundamental dentro del aprendizaje supervisado cuyo objetivo es asignar observaciones a categorías predefinidas basándose en un conjunto conocido de características. Este tipo de modelos aprenden a partir de datos etiquetados, donde cada instancia cuenta con una clase o categoría asociada, para después predecir la clase de nuevas observaciones. La clasificación se aplica en diversos campos y problemas donde es necesario discriminar entre dos o más opciones. A continuación, se detalla la división de los datos y la implementación de cada modelo utilizado para evaluar su desempeño en la clasificación.

## División de los datos

Para el desarrollo de los modelos de clasificación, se realizó un muestreo estratificado balanceado seguido de una partición aleatoria, con el objetivo de mitigar el desbalance inherente en el dataset original de Lending Club, donde aproximadamente el 80% de las observaciones corresponden a préstamos pagados y cerca del 20% a incumplimientos, lo que podría sesgar los algoritmos hacia la clase mayoritaria. Inicialmente, de la base filtrada y limpia ("lending_base"), se extrajo una muestra aleatoria de 10,000 observaciones utilizando sample_n() en R con semilla fija set.seed(28) para reproducibilidad: 5,000 de la clase "Paga" y 5,000 de "No_paga", aplicando undersampling a la clase dominante para igualar las proporciones y mejorar la sensibilidad de los modelos en la detección de riesgos crediticios. Esta técnica de balanceo es estándar en problemas de clasificación binaria desbalanceada, como los de préstamos P2P, ya que permite evaluaciones más robustas de métricas como precisión, recall y AUC sin requerir oversampling sintético.

Posteriormente, la muestra balanceada ("lending_muestra") se dividió en subconjuntos de entrenamiento (75% de las observaciones, equivalente a 7,500 registros) y prueba (25%, o 2,500 registros), utilizando sample() con la misma semilla para mantener la aleatoriedad controlada y preservar el equilibrio equitativo entre clases en ambos conjuntos (aproximadamente 50% "Paga" y 50% "No_paga"). La proporción 75/25 es una convención común en machine learning para clasificación, ya que proporciona suficientes datos para el entrenamiento mientras reserva un conjunto de prueba independiente para validar el rendimiento generalizado, evitando sobreajuste en datasets de riesgo crediticio como el de Lending Club. Esta división se implementó mediante índices aleatorios index_entrena e index_test, asegurando que las variables predictoras (numéricas y categóricas) se mantuvieran representativas en ambos subconjuntos para una evaluación imparcial de los modelos KNN y logit.

```{r tabla_proporcion}

clases <- lending_base %>%
  group_by(estado_pago) %>%
  summarise(
    N_observaciones = n(),
    Porcentaje = round(100 * n() / nrow(lending_base), 2),
    .groups = 'drop'
  )
tabla_clases=clases %>%
  kbl(
    caption = "Tabla 1. Distribución de clases antes del balanceo",
    align = c("l", "r", "r"),
    col.names = c("Estado de pago", "N observaciones", "Porcentaje (%)")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    font_size = 14,
    position = "center"
  ) %>%
    row_spec(0, background = "#2b6cb0", color = "white", bold = TRUE) %>%
  column_spec(1, bold = TRUE, width = "3.5cm") %>%
  column_spec(2:3, width = "3cm") %>%
  footnote(
    general = "Fuente: Elaboración propia con base en el dataset Lending Club (2007–2018).",
    general_title = "Nota:",
    footnote_as_chunk = TRUE
  )
tabla_clases
```

## Modelo KNN

El modelo K-Nearest Neighbors (KNN) es un algoritmo de aprendizaje supervisado no paramétrico, ampliamente utilizado para problemas de clasificación, donde predice la clase de un nuevo punto de datos basándose en la mayoría de clases de sus k vecinos más cercanos en el espacio de características. Este método opera de manera "perezosa", ya que no construye un modelo explícito durante el entrenamiento, sino que almacena el conjunto de datos y realiza cálculos de distancia (como la euclidiana) solo en el momento de la predicción, lo que lo hace simple e intuitivo para capturar patrones locales en los datos.

### Modelo KNN (class)

El proceso para entrenar y evaluar el modelo K-Nearest Neighbors (KNN) con el paquete class en R se llevó a cabo en varias etapas. Primero, se dividió el conjunto de datos en variables predictoras y variable respuesta explícitamente, seleccionando únicamente variables numéricas estandarizadas para calcular las distancias, dado que la función knn() no admite variables cualitativas directamente o factores como entradas.

Para determinar el valor óptimo de k, se implementó un ciclo for que evaluó la precisión del modelo para diferentes valores de k entre 1 y 100, calculando la proporción de predicciones correctas en el conjunto de prueba. Esta metodología manual permitió identificar el valor de k que maximiza la precisión en el rango.

Se generó un gráfico que muestra la precisión del modelo en función del valor de k, facilitando la identificación visual del punto óptimo. Con este valor seleccionado, el modelo final se evaluó utilizando métricas como la matriz de confusión y la precisión general, lo que permitió medir su capacidad para clasificar correctamente la variable objetivo.

```{r knn_class}
Grafico_precision <- ggplot(resultado, aes(x = k, y = precision)) +
  geom_line(color = "#1a5276", linewidth = 1.1) +
  geom_point(aes(color = precision), size = 2.5, alpha = 0.8) +
  scale_color_gradient(
    low = "#aed6f1",
    high = "#1a5276",
    name = "Precisión",
    labels = percent_format(accuracy = 1)
  ) +
  geom_vline(xintercept = k_optimo, color = "#c0392b", linetype = "dashed", linewidth = 1) +
  annotate("text", x = k_optimo, y = max(resultado$precision),
           label = paste("k óptimo =", k_optimo),
           color = "#c0392b", hjust = -0.1, vjust = -1, size = 3.8, fontface = "bold") +
  labs(
    title = "Figura 2. Precisión del modelo KNN según número de vecinos (k)",
    subtitle = "El valor óptimo de k maximiza la precisión de clasificación en el conjunto de prueba",
    x = "Número de vecinos (k)",
    y = "Precisión",
    caption = "Fuente: Elaboración propia con base en el dataset Lending Club (2007–2018)"
  ) +
  tema +
  theme(
    text = element_text(family = "sans"),
    plot.title = element_text(face = "bold", size = 15, hjust = 0.5, color = "#2c3e50"),
    plot.subtitle = element_text(size = 11, hjust = 0.5, color = "#34495e"),
    plot.caption = element_text(size = 9, color = "#7f8c8d", hjust = 0.5),
    axis.title = element_text(face = "bold", size = 11, color = "#2c3e50"),
    legend.position = "bottom"
  )

```

```{r precision_class}
Grafico_precision <- ggplot(resultado, aes(x = k, y = precision)) +
  geom_line(color = "#1a5276", linewidth = 1.1) +
  geom_point(aes(color = precision), size = 2.5, alpha = 0.8) +
  scale_color_gradient(
    low = "#aed6f1",
    high = "#1a5276",
    name = "Precisión",
    labels = percent_format(accuracy = 1)
  ) +
  geom_vline(xintercept = k_optimo, color = "#c0392b", linetype = "dashed", linewidth = 1) +
  annotate("text", x = k_optimo, y = max(resultado$precision),
           label = paste("k óptimo =", k_optimo),
           color = "#c0392b", hjust = -0.1, vjust = -1, size = 3.8, fontface = "bold") +
  labs(
    title = "Figura 2. Precisión del modelo KNN según número de vecinos (k)",
    subtitle = "El valor óptimo de k maximiza la precisión de clasificación en el conjunto de prueba",
    x = "Número de vecinos (k)",
    y = "Precisión",
    caption = "Fuente: Elaboración propia con base en el dataset Lending Club (2007–2018)"
  ) +
  tema +
  theme(
    text = element_text(family = "sans"),
    plot.title = element_text(face = "bold", size = 15, hjust = 0.5, color = "#2c3e50"),
    plot.subtitle = element_text(size = 11, hjust = 0.5, color = "#34495e"),
    plot.caption = element_text(size = 9, color = "#7f8c8d", hjust = 0.5),
    axis.title = element_text(face = "bold", size = 11, color = "#2c3e50"),
    legend.position = "bottom"
  )
```

### Modelo KNN (caret)

## Modelo Logit

El modelo de regresión logística (logit) es un algoritmo de aprendizaje supervisado paramétrico diseñado principalmente para clasificación binaria, que estima la probabilidad de que una observación pertenezca a una clase específica (por ejemplo, pago o no pago) mediante la aplicación de la función sigmoide a una combinación lineal de las variables predictoras. A diferencia de la regresión lineal, transforma las salidas en valores entre 0 y 1, permitiendo interpretaciones probabilísticas y umbrales para decisiones de clasificación, lo que lo hace ideal para modelar relaciones no lineales en datos categóricos.

# Comparación de modelos

# Conclusiones

# Bibliografia

rfirawvjbkwbj

```{r setup, include=FALSE}



knitr::opts_chunk$set(echo = TRUE)
```

```{r cars}
```

```{r pressure, echo=FALSE}
```

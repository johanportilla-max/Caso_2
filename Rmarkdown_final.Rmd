---
title: "Modelos de Clasificación para Riesgo Crediticio"
author: "Barros Rayo Alejandro (2415837), Muñoz Portela Diego Fernando (2415620), Portilla Aguirre Johan Camilo (2422468), Aguirre Aldana Joan Sebastian (2419550)"
output: 
  html_document:
    theme: lumen
    highlight: textmate
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    toc_depth: 3
    number_sections: true
    code_folding: show
---

# Introducción

# Metodología

## Fuente de datos

## Definición de variables

## Preparación y limpieza de datos

# Análisis descriptivo

```{r sep, echo = FALSE, warning = FALSE, message = FALSE}

knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(dplyr)
library(tidyr)
library(readr)
library(tidyverse)
library(class)
library(caret)
library(pROC)
library(ggthemes)
library(lubridate)
library(kableExtra)
library(knitr)
library(ggcorrplot)
library(scales)
library(gridExtra)
library(grid)
library(ggplotify)

```

```{r tema2, echo = FALSE, warning = FALSE, message = FALSE}
tema <- theme_minimal() +
  theme(
    text = element_text(family = "Segoe UI", color = "#2d3748"),
    plot.title = element_text(face = "bold", size = 18, hjust = 0.5, color = "#323130"),
    plot.subtitle = element_text(size = 12, hjust = 0.5, color = "#605e5c", margin = margin(b = 15)),
    plot.caption = element_text(size = 10, color = "#605e5c", hjust = 0),
    panel.grid.major = element_line(color = "#f3f2f1"),
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = "white", color = NA),
    panel.background = element_rect(fill = "white", color = NA),
    axis.title = element_text(face = "bold", color = "#323130"),
    axis.text = element_text(color = "#605e5c"),
    legend.position = "none"
  )
```

```{r carga_datos, echo = FALSE, warning = FALSE, message = FALSE}
lending_raw <- read_csv("LC_loans_granting_model_dataset.csv", guess_max = 20000)

lending_base <- lending_raw %>%
  select(revenue, dti_n, loan_amnt, fico_n, Default, purpose, issue_d) %>%
  rename(
    ingreso = revenue,
    relacion_deuda_ingreso = dti_n,
    monto_prestamo = loan_amnt,
    puntaje_fico = fico_n,
    estado_pago = Default,
    proposito = purpose
  ) %>%
  mutate(
    fecha_emision = parse_date_time(issue_d, orders = "b-Y", locale = "en_US"),
    Año = year(fecha_emision),
    proposito = as.factor(proposito),
    proposito_agrupado = fct_collapse(
      proposito,
      Consolidacion = c("debt_consolidation", "credit_card"),
      Casa_Vehiculo = c("home_improvement", "major_purchase", "car", "house"),
      Negocio_Estudio = c("small_business", "educational")
    ),
    proposito_agrupado = fct_other(
      proposito_agrupado,
      keep = c("Consolidacion", "Casa_Vehiculo", "Negocio_Estudio"),
      other_level = "Otros"
    ),
    estado_pago = fct_recode(as.factor(estado_pago), "Paga" = "0", "No_paga" = "1")
  ) %>%
  select(-proposito)

lending_base <- lending_base %>%
  filter(ingreso <= 250000, relacion_deuda_ingreso <= 50) %>%
  drop_na()
```

```{r resumen_general, echo = FALSE, warning = FALSE, message = FALSE}

resumen_general <- lending_base %>%
  select(ingreso, relacion_deuda_ingreso, monto_prestamo, puntaje_fico) %>%
  summarise_all(list(
    n = ~sum(!is.na(.)),
    media = ~mean(., na.rm = TRUE),
    mediana = ~median(., na.rm = TRUE),
    sd = ~sd(., na.rm = TRUE),
    minimo = ~min(., na.rm = TRUE),
    maximo = ~max(., na.rm = TRUE)
  )) %>%
  pivot_longer(
    cols = everything(),
    names_to = c("variable", ".value"),
    names_pattern = "^(.*)_(n|media|mediana|sd|minimo|maximo)$"
  )
```

##titulo1 Introducción general del dataset

```{r tabla_resumen }

tabla_resumen = resumen_general %>%
  select(-n) %>%  
  kable(
    format = "html",
    col.names = c("Variable", "Media", "Mediana", "Desv. Estándar", "Mínimo", "Máximo"),
    align = c('l', 'r', 'r', 'r', 'r', 'r'),
    caption = "Tabla 1: Estadísticas Descriptivas de las Variables Principales del Dataset de Préstamos"
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    font_size = 14,
    position = "center"
  ) %>%
  row_spec(0, background = "#2b6cb0", color = "white", bold = TRUE) %>%
  column_spec(1, bold = TRUE, width = "3cm") %>%
  column_spec(2, width = "2cm") %>%
  column_spec(3, width = "2cm") %>%
  column_spec(4, width = "2.5cm") %>%
  column_spec(5, width = "2cm") %>%
  column_spec(6, width = "2cm") %>%
  footnote(
    general = "Fuente: Elaboración propia con base en datos de Lending Club",
    general_title = "Nota:",
    footnote_as_chunk = TRUE
  )

tabla_resumen
```

palabras sobre la tabla

```{r tabla_frecuencias}

tabla_estado <- as.data.frame(table(lending_base$estado_pago))
colnames(tabla_estado) <- c("estado_pago", "n")
tabla_estado$porcentaje <- round(prop.table(tabla_estado$n) * 100, 2)

tabla_estado %>%
  kbl(
    caption = "Tabla 2: Distribución de Frecuencias por Estado de Pago",
    align = c("l", "r", "r"),
    col.names = c("Estado Pago", "Frecuencia", "Porcentaje (%)")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    font_size = 14,
    position = "center"
  ) %>%
  row_spec(0, background = "#2b6cb0", color = "white", bold = TRUE) %>%
  column_spec(1, bold = TRUE, width = "3cm") %>%
  column_spec(2:3, width = "2.5cm") %>%
  footnote(
    general = "Fuente: Elaboración propia con base en datos de Lending Club",
    general_title = "Nota:",
    footnote_as_chunk = TRUE
  )
```

hablar sobre tabla 2

##titulo2 Distribución individual de variables numéricas

```{r p1}
library(plotly)

p1 <- ggplot(lending_base, aes(x = ingreso)) +
  geom_histogram(binwidth = 5000,
                 fill = "#2b6cb0",
                 color = "white",
                 alpha = 0.8) +
  geom_vline(xintercept = median(lending_base$ingreso, na.rm = TRUE),
             color = "red", linetype = "dashed", size = 0.9) +
  scale_x_continuous(labels = scales::dollar_format(prefix = "$", big.mark = ",")) +
  scale_y_continuous(labels = scales::comma_format()) +
  labs(
    title = "Histograma de ingreso (mediana en rojo)",
    x = "Ingreso",
    y = "Frecuencia"
  ) +
  tema
p1

```

comentario histograma

```{r pdti}
p_dti <- ggplot(lending_base, aes(x = relacion_deuda_ingreso)) +
  geom_density(fill = "#2a9d8f",       
               color = "#1b4d47",      
               alpha = 0.4,
               size = 1.1) +
  geom_vline(aes(xintercept = median(relacion_deuda_ingreso, na.rm = TRUE)),
             color = "red", linetype = "dashed", size = 0.9) +
  scale_x_continuous(labels = scales::percent_format(scale = 1)) +
  scale_y_continuous(labels = scales::comma_format()) +
  labs(
    title = "Distribución de la relación deuda/ingreso",
    x = "Relación deuda/ingreso (%)",
    y = "Densidad"
  ) +
  tema

p_dti


```

comentario distribucion

```{r fico}
p_fico <- ggplot(lending_base, aes(x = puntaje_fico)) +
  geom_density(
    bw = 15,                # suaviza la curva (ajusta entre 10–25 según tus datos)
    fill = "#52b788",       # verde más elegante
    color = "#1b4332",      # borde oscuro
    alpha = 0.8,
    size = 1.1
  ) +
  geom_vline(
    xintercept = median(lending_base$puntaje_fico, na.rm = TRUE),
    color = "#e63946", linetype = "dashed", size = 1
  ) +
  scale_x_continuous(
    breaks = seq(600, 850, 25),
    limits = c(600, 850)
  ) +
  scale_y_continuous(
    expand = expansion(mult = c(0, 0.05)),
    labels = scales::comma_format()
  ) +
  labs(
    title = "Distribución del puntaje FICO",
    x = "Puntaje FICO",
    y = "Densidad"
  ) +
  tema +
  theme(
    plot.title = element_text(face = "bold", size = 14, color = "#1b4332"),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    panel.grid.minor = element_blank()
  )

p_fico


```

comentario fico

```{r p_monto}
p_monto_hist <- ggplot(lending_base, aes(x = monto_prestamo)) +
  geom_histogram(binwidth = 1000,
                 fill = "#2a9d8f",  
                 color = "white",
                 alpha = 0.9) +
  geom_vline(aes(xintercept = median(monto_prestamo, na.rm = TRUE)),
             color = "red", linetype = "dashed", size = 0.9) +
  scale_x_continuous(labels = dollar_format(prefix = "$", big.mark = ",")) +
  scale_y_continuous(labels = comma_format()) +
  labs(
    title = "Distribución del monto del préstamo (mediana en rojo)",
    x = "Monto del préstamo (USD)",
    y = "Frecuencia"
  ) +
  tema
p_monto_hist

```

comentario monto

##titulo3 Comparación entre clases (Paga vs No_paga)

```{r ficopagaono}
p_fico_box <- ggplot(lending_base, aes(x = estado_pago, y = puntaje_fico, fill = estado_pago)) +
geom_boxplot() +
labs(
title = "Puntaje FICO por estado de pago",
x = "Estado de pago",
y = "Puntaje FICO"
) +
tema
print(p_fico_box)


```


```{r ingresopaga on o paga}

p_box_ingreso <- ggplot(lending_base, aes(x = estado_pago, y = ingreso, fill = estado_pago)) +
geom_boxplot(alpha = 0.7, outlier.color = "gray40", outlier.alpha = 0.4) +
scale_fill_manual(values = c("Paga" = "#1b9e77", "No_paga" = "#d95f02")) +
scale_y_continuous(labels = scales::dollar_format(prefix = "$", big.mark = ",")) +
labs(
title = "Distribución del ingreso por estado de pago",
subtitle = "Comparación mediante boxplots (mediana y dispersión)",
x = "Estado de pago",
y = "Ingreso (USD)"
) +
tema
p_box_ingreso
```


```{r todasvariable}

p_comparativo <- lending_base %>%
pivot_longer(cols = c(ingreso, relacion_deuda_ingreso, monto_prestamo, puntaje_fico),
names_to = "variable", values_to = "valor") %>%
ggplot(aes(x = estado_pago, y = valor, fill = estado_pago)) +
geom_boxplot(alpha = 0.6, outlier.alpha = 0.3) +
facet_wrap(~ variable, scales = "free", ncol = 2) +
scale_y_continuous(labels = comma) +
scale_fill_manual(values = c("Paga" = "#1b9e77", "No_paga" = "#d95f02")) +
labs(
title = "Comparación de variables numéricas según estado de pago",
subtitle = "Boxplots por clase (Paga vs No_paga)",
x = "Estado de pago",
y = "Valor"
) +
tema
print(p_comparativo)
```






```{r fico_dti_simplificado}

set.seed(123)

sample_plot <- lending_base %>% sample_n(min(8000, nrow(.)))

p_fico_dti <- ggplot(sample_plot, aes(x = puntaje_fico, y = relacion_deuda_ingreso)) +
  geom_smooth(
    method = "loess",
    se = TRUE,
    color = "#1b4332",
    fill = "#95d5b2",
    linewidth = 1.2,
    alpha = 0.3
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1)) +
  scale_x_continuous(breaks = seq(600, 850, 25)) +
  labs(
    title = "Relación entre puntaje FICO y relación deuda/ingreso",
    
    x = "Puntaje FICO",
    y = "Relación deuda/ingreso (%)"
  ) +
  tema +
  theme(
    legend.position = "none",
    plot.subtitle = element_text(size = 11, color = "#555"),
    panel.grid.minor = element_blank()
  )

p_fico_dti

```


```{r montovsingresos}
corr_val <- cor(lending_base$ingreso, lending_base$monto_prestamo, use = "complete.obs")

p_monto <- ggplot(lending_base, aes(x = ingreso, y = monto_prestamo)) +
  geom_point(aes(color = estado_pago),
             alpha = 0.35, size = 1.4) +
  geom_smooth(
    method = "gam",
    formula = y ~ s(x, bs = "cs"),
    color = "#264653",
    fill = "#a8dadc",
    size = 1,
    se = TRUE
  ) +
  scale_x_continuous(
    labels = dollar_format(prefix = "$", big.mark = ","),
    expand = expansion(mult = c(0.02, 0.02))
  ) +
  scale_y_continuous(
    labels = dollar_format(prefix = "$", big.mark = ","),
    expand = expansion(mult = c(0.02, 0.02))
  ) +
  scale_color_manual(
    values = c("Paga" = "#2a9d8f", "No_paga" = "#e76f51"),
    name = "Estado de pago"
  ) +
  labs(
    title = "Relación entre ingreso y monto del préstamo",
    subtitle = paste("Correlación:", round(corr_val, 2)),
    x = "Ingreso del solicitante (USD)",
    y = "Monto del préstamo (USD)"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    legend.position = "bottom",
    plot.title = element_text(face = "bold", color = "#1d3557"),
    plot.subtitle = element_text(color = "#457b9d"),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.major.y = element_line(color = "gray90"),
    plot.margin = margin(10, 15, 10, 15)
  )

p_monto
```


## Distribución de las variables principales

## Caracterización de las clases

## Comportamiento según propósito del préstamo

# Modelos de clasificación

La clasificación es un enfoque fundamental dentro del aprendizaje supervisado cuyo objetivo es asignar observaciones a categorías predefinidas basándose en un conjunto conocido de características. Este tipo de modelos aprenden a partir de datos etiquetados, donde cada instancia cuenta con una clase o categoría asociada, para después predecir la clase de nuevas observaciones. La clasificación se aplica en diversos campos y problemas donde es necesario discriminar entre dos o más opciones. A continuación, se detalla la división de los datos y la implementación de cada modelo utilizado para evaluar su desempeño en la clasificación.

## División de los datos

Para el desarrollo de los modelos de clasificación, se realizó un muestreo estratificado balanceado seguido de una partición aleatoria, con el objetivo de mitigar el desbalance inherente en el dataset original de Lending Club, donde aproximadamente el 80% de las observaciones corresponden a préstamos pagados y cerca del 20% a incumplimientos, lo que podría sesgar los algoritmos hacia la clase mayoritaria. Inicialmente, de la base filtrada y limpia ("lending_base"), se extrajo una muestra aleatoria de 10,000 observaciones utilizando sample_n() en R con semilla fija set.seed(28) para reproducibilidad: 5,000 de la clase "Paga" y 5,000 de "No_paga", aplicando undersampling a la clase dominante para igualar las proporciones y mejorar la sensibilidad de los modelos en la detección de riesgos crediticios. Esta técnica de balanceo es estándar en problemas de clasificación binaria desbalanceada, como los de préstamos P2P, ya que permite evaluaciones más robustas de métricas como precisión, recall y AUC sin requerir oversampling sintético.

Posteriormente, la muestra balanceada ("lending_muestra") se dividió en subconjuntos de entrenamiento (75% de las observaciones, equivalente a 7,500 registros) y prueba (25%, o 2,500 registros), utilizando sample() con la misma semilla para mantener la aleatoriedad controlada y preservar el equilibrio equitativo entre clases en ambos conjuntos (aproximadamente 50% "Paga" y 50% "No_paga"). La proporción 75/25 es una convención común en machine learning para clasificación, ya que proporciona suficientes datos para el entrenamiento mientras reserva un conjunto de prueba independiente para validar el rendimiento generalizado, evitando sobreajuste en datasets de riesgo crediticio como el de Lending Club. Esta división se implementó mediante índices aleatorios index_entrena e index_test, asegurando que las variables predictoras (numéricas y categóricas) se mantuvieran representativas en ambos subconjuntos para una evaluación imparcial de los modelos KNN y logit.

```{r tabla_proporcion}

clases <- lending_base %>%
  group_by(estado_pago) %>%
  summarise(
    N_observaciones = n(),
    Porcentaje = round(100 * n() / nrow(lending_base), 2),
    .groups = 'drop'
  )
tabla_clases=clases %>%
  kbl(
    caption = "Tabla 1. Distribución de clases antes del balanceo",
    align = c("l", "r", "r"),
    col.names = c("Estado de pago", "N observaciones", "Porcentaje (%)")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    font_size = 14,
    position = "center"
  ) %>%
    row_spec(0, background = "#2b6cb0", color = "white", bold = TRUE) %>%
  column_spec(1, bold = TRUE, width = "3.5cm") %>%
  column_spec(2:3, width = "3cm") %>%
  footnote(
    general = "Fuente: Elaboración propia con base en el dataset Lending Club (2007–2018).",
    general_title = "Nota:",
    footnote_as_chunk = TRUE
  )
tabla_clases
```

```{r particion}
set.seed(28)
paga <- lending_base %>% filter(estado_pago == "Paga") %>% sample_n(5000)
nopaga <- lending_base %>% filter(estado_pago == "No_paga") %>% sample_n(5000)
lending_muestra <- bind_rows(paga, nopaga) %>% arrange(sample(1:n()))

set.seed(28)
index_muestra <- sample(1:nrow(lending_muestra), nrow(lending_muestra))
index_entrena <- sample(index_muestra, floor(0.75 * length(index_muestra)))
index_test <- setdiff(index_muestra, index_entrena)

train <- lending_muestra[index_entrena, ]
test <- lending_muestra[index_test, ]
```

## Modelo KNN

El modelo K-Nearest Neighbors (KNN) es un algoritmo de aprendizaje supervisado no paramétrico, ampliamente utilizado para problemas de clasificación, donde predice la clase de un nuevo punto de datos basándose en la mayoría de clases de sus k vecinos más cercanos en el espacio de características. Este método opera de manera "perezosa", ya que no construye un modelo explícito durante el entrenamiento, sino que almacena el conjunto de datos y realiza cálculos de distancia solo en el momento de la predicción, lo que lo hace simple e intuitivo para capturar patrones locales en los datos.

### Modelo KNN (class)

El proceso para entrenar y evaluar el modelo K-Nearest Neighbors (KNN) con el paquete class en R se llevó a cabo en varias etapas. Primero, se dividió el conjunto de datos en variables predictoras y variable respuesta explícitamente, seleccionando únicamente variables numéricas estandarizadas para calcular las distancias, dado que la función knn() no admite variables cualitativas directamente o factores como entradas.

Por simplicidad y dadas las características del paquete class, en esta fase no se utilizó la variable cualitativa `proposito_agrupado`. La inclusión de variables categóricas habría requerido transformarlas a variables numéricas y estandarizarlas, lo cual añade complejidad. Esta decisión permitió enfocar el análisis en las variables cuantitativas. El manejo de variables cualitativas se dejará para fases posteriores o para el uso de paquetes más flexibles.

```{r particion_class}
vars_input <- c("ingreso", "relacion_deuda_ingreso", "monto_prestamo", "puntaje_fico")
train_input <- train[, vars_input]
test_input  <- test[, vars_input]
train_output <- train$estado_pago
test_output  <- test$estado_pago

k_vals <- 1:100
resultado <- data.frame(k = k_vals, precision = 0)

scaler <- preProcess(train_input, method = c("center", "scale"))
train_input_scaled <- predict(scaler, train_input)
test_input_scaled  <- predict(scaler, test_input)


for (n in k_vals) {
  pred_temp <- knn(train = train_input_scaled, test = test_input_scaled, cl = train_output, k = n)
  resultado$precision[n] <- mean(pred_temp == test_output)
}

k_optimo <- resultado$k[which.max(resultado$precision)]
prec_opt <- max(resultado$precision)

pred_knn <- knn(train = train_input, test =test_input, cl = train_output,
                k = k_optimo)
```

Para determinar el valor óptimo de k, se implementó un ciclo for que evaluó la precisión del modelo para diferentes valores de k entre 1 y 100, calculando la proporción de predicciones correctas en el conjunto de prueba. Esta metodología manual permitió identificar el valor de k que maximiza la precisión en el rango.

Se generó un gráfico que muestra la precisión del modelo en función del valor de k, facilitando la identificación visual del punto óptimo. Con este valor seleccionado, el modelo final se evaluó utilizando métricas como la matriz de confusión y la precisión general, lo que permitió medir su capacidad para clasificar correctamente la variable objetivo.

```{r precision_class}
Grafico_precision <- ggplot(resultado, aes(x = k, y = precision)) +
  geom_line(color = "#1a5276", linewidth = 1.1) +
  geom_point(aes(color = precision), size = 2.5, alpha = 0.8) +
  scale_color_gradient(
    low = "#aed6f1",
    high = "#1a5276",
    name = "Precisión",
    labels = percent_format(accuracy = 1)
  ) +
  geom_vline(
    xintercept = k_optimo,
    color = "#c0392b",
    linetype = "dashed",
    linewidth = 1
  ) +
  annotate(
    "label",
    x = k_optimo,
    y = max(resultado$precision) - 0.015,
    label = paste("k óptimo =", k_optimo),
    color = "white",
    fill = "#c0392b",
    size = 3.5,
    fontface = "bold",
    label.size = 0.3,
    label.padding = unit(0.15, "lines")
  ) +
  labs(
    title = "Precisión del modelo KNN según número de vecinos (k)",
    subtitle = "El valor óptimo de k maximiza la precisión de clasificación en el conjunto de prueba",
    x = "Número de vecinos (k)",
    y = "Precisión",
    caption = "Fuente: Elaboración propia con base en el dataset Lending Club (2007–2018)"
  ) +
  tema +
  theme(
    text = element_text(family = "Segoe UI"),
    plot.title = element_text(face = "bold", size = 15, hjust = 0.5, color = "#2c3e50"),
    plot.subtitle = element_text(size = 11, hjust = 0.5, color = "#34495e", margin = margin(b = 10)),
    plot.caption = element_text(size = 9, color = "#7f8c8d", hjust = 0.5, margin = margin(t = 15)),
    axis.title = element_text(face = "bold", size = 11, color = "#2c3e50"),
    legend.position = "bottom",
    legend.title = element_text(face = "bold", color = "#2c3e50"),
    legend.text = element_text(color = "#34495e")
  )

Grafico_precision
```

Luego de analizar la gráfica de precisión para distintos valores de k, se eligió k = `r k_optimo`, que corresponde al punto donde el modelo alcanza su mayor porcentaje de aciertos en la clasificación sobre el conjunto de prueba `r scales::percent(prec_opt, accuracy = 0.1)`. Este valor de k fue utilizado para entrenar el modelo y obtener las métricas de desempeño que se presentan.

A continuación, se reportan la matriz de confusión y la tabla de indicadores principales de evaluación para documentar el rendimiento del modelo KNN con este valor de k.

```{r confucion_class}

cm <- confusionMatrix(pred_knn, test_output, positive = "No_paga")

matriz_conf <- as.data.frame(cm$table)

matriz_tabla <- matrix(
  c(matriz_conf$Freq[1], matriz_conf$Freq[2],
    matriz_conf$Freq[3], matriz_conf$Freq[4]),
  nrow = 2, byrow = TRUE,
  dimnames = list(
    "Predicción" = c("Paga", "No_paga"),
    "Referencia" = c("Paga", "No_paga")
  )
)

matriz_tabla %>%
  kbl(
    caption = "    Matriz de Confusión del Modelo KNN (class)",
    align = c("c", "c", "c"),
    col.names = c("Paga", "No_paga")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    font_size = 14,
    position = "center"
  ) %>%
  row_spec(0, background = "#2b6cb0", color = "white", bold = TRUE) %>%
  column_spec(1, width = "3cm", bold = TRUE) %>%
  add_header_above(c(" " = 1, "Referencia" = 2), bold = TRUE, background = "#2b6cb0", color = "white") %>%
  footnote(
    general = "La matriz muestra las predicciones frente a los valores reales para la clase positiva 'No_paga'.",
    general_title = "Nota:",
    footnote_as_chunk = TRUE
  )

metricas_knn <- data.frame(
  Indicador = c(
    "Accuracy (Exactitud)",
    "95% CI",
    "No Information Rate", 
    "P-Value [Acc > NIR]",
    "Kappa",
    "Mcnemar's Test P-Value",
    "Sensitivity",
    "Specificity",
    "Pos Pred Value",
    "Neg Pred Value", 
    "Prevalence",
    "Detection Rate",
    "Detection Prevalence",
    "Balanced Accuracy"
  ),
  Descripción = c(
    "Proporción total de predicciones correctas",
    "Intervalo de confianza del 95% para exactitud",
    "Tasa al predecir siempre clase mayoritaria",
    "Valor p vs tasa no información",
    "Acuerdo ajustado por azar",
    "Test de McNemar para diferencias entre clases",
    "Capacidad detectar 'No_paga' (VP / VP+FN)",
    "Capacidad detectar 'Paga' (VN / VN+FP)", 
    "Precisión para clase 'No_paga'",
    "Precisión para clase 'Paga'",
    "Proporción real de 'No_paga'",
    "Tasa de detección de 'No_paga'",
    "Proporción predicha de 'No_paga'",
    "Promedio sensibilidad y especificidad"
  ),
  Valor = c(
    "0.5564", "(0.5367, 0.5760)", "0.5104", "2.25e-06", "0.1135", "0.03061",
    "0.5768", "0.5368", "0.5443", "0.5694", "0.4896", "0.2824", "0.5188", "0.5568"
  )
)

tabla_metricas <- metricas_knn %>%
  kbl(
    caption = "Métricas de Evaluación - Modelo KNN",
    align = c("l", "l", "c"),
    col.names = c("Métrica", "Descripción", "Valor")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    font_size = 12,
    position = "center"
  ) %>%
  row_spec(0, background = "#2b6cb0", color = "white", bold = TRUE) %>%
  column_spec(1, bold = TRUE, width = "3cm") %>%
  column_spec(2, width = "6cm") %>%
  column_spec(3, width = "2cm")

tabla_metricas

```

Los resultados alcanzados por el modelo KNN utilizando el paquete class reflejan un desempeño bastante modesto en la tarea de clasificación entre préstamos pagados y no pagados. La exactitud obtenida, de solo 55.6%, es apenas superior a la que se lograría clasificando siempre la clase más frecuente en la muestra (No Information Rate: 51%), lo que muestra la dificultad inherente al problema y a la información contenida en las variables numéricas utilizadas.

El estadístico Kappa (0.11) es bajo, señalando que el acuerdo entre las predicciones del modelo y el resultado real es solo marginalmente mejor que el azar. Asimismo, tanto la sensibilidad (57.7%) como la especificidad (53.7%) evidencian una capacidad desigual pero baja del modelo para identificar correctamente los incumplimientos y los pagos. Ninguna de las dos clases es clasificada con gran efectividad, lo que refleja limitaciones importantes cuando se busca un sistema confiable para apoyar decisiones en la concesión de pretamos.

Al observar los valores predictivos (positivo: 54.4% para "No_paga", negativo: 56.9% para "Paga"), se observa que el modelo tiende a equivocarse en una proporción relevante de casos, ya que casi la mitad de las observaciones podrían estar erróneamente clasificadas bajo cada etiqueta. Además, el valor de la exactitud balanceada (55.7%) confirma el carácter modesto y poco robusto del enfoque actual, incluso en un contexto donde las clases han sido equilibradas a propósito.

En concreto, aunque el modelo muestra una ligera capacidad para mejorar la predicción respecto al azar, su potencial real es muy limitado bajo las condiciones y supuestos aplicados. 

### Modelo KNN (caret)

El ajuste y evaluación del modelo KNN usando el paquete caret se realizó con el objetivo de aprovechar un proceso estandarizado y más flexible. A diferencia de la función clásica de class, caret permite incluir tanto variables numéricas como categóricas (conversión automática a variables dummy) y automatiza la validación cruzada, la selección de hiperparámetros y la obtención de métricas clave a través de un solo flujo de trabajo.

Se configuró el control de entrenamiento para usar validación cruzada de 5 pliegues, estimación de probabilidades y optimización según el área bajo la curva ROC. El modelo fue entrenado sobre el conjunto de entrenamiento considerando las variables ingreso, relacion_deuda_ingreso, monto_prestamo, puntaje_fico y proposito_agrupado, permitiendo así una mayor riqueza informativa respecto al modelo anterior.

La función `caret::train()` exploró simultáneamente múltiples valores de k, normalizó las variables e identificó el valor óptimo en función del desempeño en predicción.

Una vez seleccionado el modelo KNN óptimo, se obtuvieron predicciones para el conjunto de prueba, junto con las probabilidades estimadas para cada clase.

```{r Entre_caret}
set.seed(28)

ctrl_knn <- trainControl(
  method = "cv",
  number = 5,
  classProbs = TRUE,
  summaryFunction = twoClassSummary
)

modelo_knn <- train(
  estado_pago ~ ingreso + relacion_deuda_ingreso + monto_prestamo + puntaje_fico + proposito_agrupado,
  data = train,
  method = "knn",
  trControl = ctrl_knn,
  preProcess = c("center", "scale"),
  tuneLength = 150,
  metric = "ROC"
)
```


El modelo evaluó diferentes configuraciones de vecinos (k = 1 a 150) mediante validación cruzada.

El valor óptimo de k seleccionado por el algoritmo fue `r modelo_knn$bestTune$k`, que alcanzó un AUC promedio de `r round(max(modelo_knn$results$ROC), 3)` durante la validación.

```{r AUC_caret}
ggplot(modelo_knn$results, aes(x = k, y = ROC)) +
  geom_line(color = "#1a5276", linewidth = 1.1) +
  geom_point(aes(color = ROC), size = 2.5, alpha = 0.8) +
  scale_color_gradient(
    low = "#aed6f1",
    high = "#1a5276",
    name = "AUC (ROC)"
  ) +
  geom_vline(xintercept = modelo_knn$bestTune$k, color = "#c0392b", linetype = "dashed") +
  annotate("label", x = modelo_knn$bestTune$k, y = max(modelo_knn$results$ROC)-0.01,
           label = paste("k óptimo =", modelo_knn$bestTune$k),
           color = "white", fill = "#c0392b", fontface = "bold") +
  labs(
    title = "AUC del modelo KNN según número de vecinos (k)",
    subtitle = "El valor óptimo de k maximiza el área bajo la curva ROC en validación cruzada (5-fold)",
    x = "Número de vecinos (k)",
    y = "Área bajo la curva (ROC)",
    caption = "Fuente: Elaboración propia con base en el dataset Lending Club (2007–2018)"
  ) +
  theme_minimal(base_family = "Segoe UI") +
  theme(
    plot.title = element_text(face = "bold", size = 15, hjust = 0.5, color = "#2c3e50"),
    plot.subtitle = element_text(size = 11, hjust = 0.5, color = "#34495e"),
    plot.caption = element_text(size = 9, color = "#7f8c8d", hjust = 0.5),
    legend.position = "bottom"
  )
```

```{r Con_caret}

cm_caret <- confusionMatrix(pred_clase_knn, test$estado_pago, positive = "No_paga")

matriz_conf <- matrix(
  c(cm_caret$table[1], cm_caret$table[2],
    cm_caret$table[3], cm_caret$table[4]),
  nrow = 2, byrow = TRUE,
  dimnames = list(
    "Predicción" = c("Paga", "No_paga"),
    "Referencia" = c("Paga", "No_paga")
  )
)

matriz_conf %>%
  kbl(
    caption = "Tabla 1. Matriz de Confusión del Modelo KNN (caret)",
    align = c("c", "c", "c"),
    col.names = c("Paga", "No_paga")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = FALSE,
    font_size = 14,
    position = "center"
  ) %>%
  row_spec(0, background = "#2b6cb0", color = "white", bold = TRUE) %>%
  column_spec(1, bold = TRUE, width = "3cm") %>%
  add_header_above(c(" " = 1, "Referencia" = 2),
                   bold = TRUE, background = "#2b6cb0", color = "white") %>%
  footnote(
    general = "La matriz muestra las predicciones frente a los valores reales para la clase positiva 'No_paga'.",
    general_title = "Nota:",
    footnote_as_chunk = TRUE
  )

```

## Modelo Logit

El modelo de regresión logística (logit) es un algoritmo de aprendizaje supervisado paramétrico diseñado principalmente para clasificación binaria, que estima la probabilidad de que una observación pertenezca a una clase específica (por ejemplo, pago o no pago) mediante la aplicación de la función sigmoide a una combinación lineal de las variables predictoras. A diferencia de la regresión lineal, transforma las salidas en valores entre 0 y 1, permitiendo interpretaciones probabilísticas y umbrales para decisiones de clasificación, lo que lo hace ideal para modelar relaciones no lineales en datos categóricos.

# Comparación de modelos

# Conclusiones

# Bibliografia

rfirawvjbkwbj

```{r setup, include=FALSE}



knitr::opts_chunk$set(echo = TRUE)
```

```{r cars}
```

```{r pressure, echo=FALSE}
```
